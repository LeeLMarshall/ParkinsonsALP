```{r}
source("../code/plots.R")
source("../code/linearFits.R")
source("../code/manhattanPlot.R")
```


### Removal of non-informative loci

```{r}
foo <- function(beta) {
  stable <- apply(beta, 1, function(I) {
    sum(is.na(I) | I == 0 | I == 1)
  })
  stable / ncol(beta)
}
# touch()
stableFraction <- cache(foo=foo, 
  fname = glue("{prefix}stable.RDS"),
  verbose = TRUE,
  beta = methylation)
```

Fraction of CGs that should be removed depending on threshold. Currently set
threshold is  `r modelparams$allowStable * 100`%


```{r, include=TRUE, results="asis"}
threshold <- floor(modelparams$allowStable * ncol(methylation)) / ncol(methylation)
stable <- stableFraction >= threshold
if (sum(stable) > 0) {
  cat(glue("> Removing {sum(stable)} stable loci.\n\n"))
  methylation <- methylation[!stable, ]
} else {
  cat("> No loci going to be removed.\n\n")
}
```

### Imputation of NA values

```{r}
if (params$mvaluesLmFit$imputeBetas == TRUE) {
  # touch()
  methylation <- cache(
    foo=impute.knn,
    fname = glue("{prefix}betaImputed.RDS"),
    verbose = TRUE,
    data = methylation, 
    k=10, 
    rowmax = modelparams$allowStable, 
    colmax = 0.5
    )
  methylation <- methylation$data
  colnames(methylation) <- data$sample$ID
}
```

```{r, include=TRUE, results="asis"}
if (modelparams$imputeBetas == TRUE) {
  cat("> Missing beta values imputed.\n\n")
} else {
  cat("> Missing beta values not imputed.\n\n")
}
```

### Conversion of Beta values to M values

```{r, include=TRUE, results="asis"}
beta2m <- function(y, fixInfinity = FALSE) {
  if (fixInfinity == TRUE) {
    n.obs <- sum(!is.na(y))
    y <- (y * (n.obs -1) + 0.5)/ n.obs    
  }
  y <- log2(y / (1-y))
  y[is.infinite(y)] <- NA
  return(y)
}

if (modelparams$useMvalues == TRUE) {
  cat("> Beta values were converted to M values.\n\n")
  methylation <- beta2m(methylation,
                        modelparams$fixInfinity)  
} else {
  cat("> Using beta values for model fits.\n\n")
}
```

```{r, include=TRUE}
hist(methylation, breaks=30)
```

### Data PCs vs Covariates

Covariates used in the model

```{r, include=TRUE}
colnames(data$modelData)
```


```{r}
# touch()
pca <- cache(
  foo = prcomp, 
  fname = glue("{prefix}pca.RDS"), 
  verbose = TRUE, 
  x = t(methylation %>% na.omit), 
  scale=FALSE, 
  center=TRUE)
```

Fit covariates to the PCs using limma

```{r, include=TRUE}
lmFit( t(pca$x[, 1:10]), 
  model.matrix(~., data$modelData)) %>% eBayes %>% topTable %>% 
  kable() %>%
  kable_styling(bootstrap_options = c("striped", "hover"))
```

The covariates significantly affecting the PCs using ANOVA:

```{r, include=TRUE}
pd <- foreach (i = 1:6, .combine=rbind) %do% {
  myanova <- lm(pca$x[,i] ~ ., data$modelData) %>% anova
  data.table(PC=i, Variable=rownames(myanova), P=myanova$`Pr(>F)`)
}
pd[Variable != "Residuals"] %>%
ggplot(., aes(Variable, -log10(P), color=as.factor(PC))) + 
  geom_point(size=4) +
  geom_hline(yintercept = -log10(0.05), color = "red", linetype="dashed") + 
  scale_color_brewer("PC", palette="Dark2") + 
  theme_bw(base_size = 10)
```


### Effect of surrogate vectors


```{r}
foo <- function(x, modelData, formula, formula0, svRange = 1:10) {
  m <- model.matrix(as.formula(formula), modelData)
  m0 <- model.matrix(as.formula(formula0), modelData)
  pca <- prcomp(t(x %>% na.omit), scale=FALSE, center = TRUE)

  # Plot 1: the amount of variation explained by the PCs
  pd <- (pca$sdev[svRange]^2 / sum(pca$sdev^2))
  pd <- data.table(PC=svRange, PVE = pd)
  p1 <- ggplot(pd, aes(PC, PVE)) + 
    geom_bar(stat="identity", width=.75, fill="lightgrey", color="black") + 
    scale_y_continuous(labels = scales::percent) + 
    scale_x_continuous(breaks = svRange, labels = svRange) +
    ggtitle("Proportion of Variance Explained") + 
    theme_bw(base_size=10)


  # Compute SVs for multiple n options
  svs <- 
    lapply(svRange, function(n) computeSVs(x, m, m0, n.sv = n, devel=FALSE))


  # Plot 2: Association of SVS and model data with principal components
  # Quite clearly SVs correspond to PCs of the betaImputed matrix
  pd <- foreach( pc = svRange, .combine=rbind) %do% {
    rsq <- lm(pca$x[, pc] ~ ., modelData) %>% summary %>% .$adj.r.squared
    rsq <- c(rsq, sapply(svRange, function(n) {
      lm(pca$x[, pc] ~ ., cbind(modelData, svs[[n]])) %>% summary %>% .$adj.r.squared
    }))
    data.table(PC = pc, NSV = c(0, svRange), Rsq = rsq)
  }
  p2 <- ggplot(pd, aes(NSV, Rsq, color = PC %>% as.factor)) +
    geom_point() + 
    geom_line() + 
    scale_y_continuous("adj. R squared", labels = scales::percent) + 
    scale_x_continuous("Number of SVs", breaks=c(0, svRange), labels=c(0, svRange)) + 
    scale_color_brewer("PC", palette="Dark2") + 
    ggtitle("PC ~ confounders + SVs") +
    theme_bw(base_size=10)



  # Treatment effect on principal component fits
  pd <- foreach( nsv = c(0, svRange), .combine=rbind) %do% {
    if (nsv == 0)
      res <- f.pvalue(t(pca$x[, 1:3]), m, m0)
    else 
      res <- f.pvalue(t(pca$x[, 1:3]), cbind(m, svs[[nsv]]), cbind(m0, svs[[nsv]]))
    data.table(NSV = nsv, t(res))
  }
  p3 <- pd %>% reshape2::melt(id.vars="NSV") %>% 
    ggplot(., aes(NSV, -log10(value), fill=variable)) + 
    geom_bar(stat="identity", position=position_dodge2()) + 
    scale_y_continuous("-log10(p)") + 
    scale_x_continuous("Number of SVs", breaks=0:10, labels=0:10) +   
    scale_fill_brewer("PC", palette="Dark2") +
    ggtitle("Diag. effect in model\nPC ~ Diag. + confounders + SVs (t-test)") + 
    theme_bw(base_size=10)

  # ANOVA estimateion of Treatment effect for increasing numbers of SVs
  pd <- foreach(nsv = c(0, svRange), .combine=rbind) %do% {
    if (nsv == 0)
      md <- modelData
    else
      md <- cbind(modelData, svs[[nsv]])
    p <- foreach (pc = 1:3, .combine=c) %do% {
      lm(pca$x[,pc] ~ ., md) %>% anova %>% .$`Pr(>F)` %>% .[1] %>% as.numeric
    }
    names(p) <- paste0("PC", 1:3)
    data.table(NSV = nsv, data.table(t(p)))
  }

  p4 <- pd %>% reshape2::melt(id.vars="NSV") %>% 
    ggplot(., aes(NSV, -log10(value), fill=variable)) + 
    geom_bar(stat="identity", position=position_dodge2()) +
    scale_y_continuous("-log10(p)") + 
    scale_x_continuous("Number of SVs", breaks=0:10, labels=0:10) +   
    scale_fill_brewer("PC", palette="Dark2") +
    ggtitle("Treatment effect in model\nPC ~ Diag. + confounders + SVs (ANOVA)") + 
    theme_bw(base_size=10)

  return(list(
    pca, svs, p1, p2, p3, p4
    ))
}
# touch()
g(pca, svs, p1, p2, p3, p4) %=% cache(foo=foo, 
  fname=glue("{prefix}choose_nsv.RDS"), 
  verbose=TRUE, 
  x=methylation, 
  modelData = data$modelData, 
  formula   = params$model$formula, 
  formula0  = params$model$formula0, 
  svRange   = params$model$svRange)

```

```{r, include=TRUE, fig.height=10}
ggarrange(p1, p2, p3, p4, ncol=2, nrow=2, labels=LETTERS[1:4], common.legend=TRUE, legend="bottom")
```

### Probe-level models {.tabset}



```{r}
# Initialize cluster
nsvoptions <- sort(unique(c(0, params$model$svRange)))
files <- c(
  glue("{prefix}fit_limma_{nsvoptions}.RDS"), 
  glue("{prefix}fit_limma_result.RDS"))
if (!all(file.exists(files))) {
  require(parallel)
  require(doSNOW)
  hosts <- rep("localhost", params$workers)
  message(sprintf("Starting cluster on %s", paste(hosts, collapse=", ")))
  mycluster <- makeCluster(hosts, type="SOCK", outfile="")    
  registerDoSNOW(mycluster)
  clusterSetupRNG(mycluster)  
}

# Run permutations
permuted <- 
  foreach(nsv = nsvoptions) %do% {
    # touch()
    cache(foo=permutationAnalysis, 
      fname=glue("{prefix}fit_limma_{nsv}.RDS"), 
      verbose=TRUE, 
      M = methylation, 
      md = data$modelData, 
      formula = params$model$formula,
      formula0 = params$model$formula0, 
      nsv = nsv, 
      nPerm = params$nPerm)
  }
names(permuted) <- as.character(nsvoptions)


# determine optimal nsv
nsv <- sapply(permuted, function(x) mean(x[1] < x[-1])) %>% which.min %>% names %>% as.numeric

# fit final model
# touch()
fit <- cache(
            foo      = getLimmaFit, 
            fname    = glue("{prefix}fit_limma_result.RDS"), 
            verbose  = TRUE, 
            M        = methylation, 
            md       = data$modelData, 
            formula  = params$model$formula,
            formula0 = params$model$formula0, 
            nsv      = nsv, 
            iteration= 0)

# stop cluster
tryCatch({
  message("Stopping cluster.")
  registerDoSEQ()
  stopCluster(mycluster)  
}, error = function(e) {})

```

```{r}

# Load padlock annotation

if (grepl("Mice", basename(getwd()))) {
  # Mouse annotation
  manual <- fread("../etc/mm10_padlock_manual.csv")
  manual[, Gene := strsplit(TargetID, split="_") %>% sapply(., `[[`, 1)]
  manual[, Chr := gsub(":.*$", "", TargetLocation)]
  manual[, Start := as.numeric(gsub("^chr.*:|-.*$", "", TargetLocation))]
  manual[, End := as.numeric(gsub("^chr.*-", "", TargetLocation))]
  manual[, Length := End - Start]
  setkey(manual, Chr, Start, End)

} else {
  # Human
  manual <- fread("../etc/PD_LYS_ordered_probes.csv", header=FALSE)
  manual <- manual$V1 %>% strsplit(split=":")
  manual <- data.table(
    Gene = sapply(manual, '[[', 1),
    Chr = sapply(manual, '[[', 2),
    Start = sapply(manual, '[[', 3) %>% 
      strsplit(split = "-") %>% 
      sapply(., '[[', 1) %>% 
      as.numeric,
    End = sapply(manual, '[[', 3) %>% 
      strsplit(split = "-") %>% 
      sapply(., '[[', 2) %>%
      as.numeric
  )
  setkey(manual, Chr, Start, End)
}

tryCatch(
  {
    setnames(data$genome, "chr", "Chr")
  }, 
  error = function(e) {}
)

fit <- merge(data$genome, fit, by="ID") %>% 
  .[, Start := SNP] %>%
  .[, End := SNP]
setkey(fit, Chr, Start, End)  


fit <- foverlaps(fit, manual, type="within", mult="first")
fit$i.Start <- fit$i.End <- fit$Start <- fit$End <- NULL

```

#### Permutation result

Optimal number of SVs selected based on the best permutation result

```{r, include=TRUE}
print(nsv)
```


```{r, include=TRUE}
p1 <- 
lapply(permuted, function(P) {
  data.table(P=mean(P[1] <= P), N = P[1])
}) %>% 
rbindlist %>% 
.[, nSV := names(permuted)] %>%
.[, Fill := FALSE] %>% 
.[nSV == nsv, Fill := TRUE] %>%
ggplot(., aes(nSV, -log10(P), fill=Fill)) + 
  geom_bar(stat = "identity", color="black", width=0.75) + 
  geom_label(aes(label=N)) + 
  geom_hline(yintercept = -log10(0.05), color="red", linetype="dashed") +
  xlab("Number of SVs") +
  ylab("-log10(P)") + 
  ggtitle("Permutation P") +
  guides(fill=FALSE) + 
  scale_fill_manual(values = c("white", "lightgrey")) +
  theme_bw(base_size=10)

# p value histogram
nsig <- fit[, sum(adj.P.Val < 0.05, na.rm=TRUE)]
p <- sapply(permuted, function(x) mean(x[1] <= x))[nsv+1] %>% format(digits=2)
p2 <-
ggplot(fit, aes(P.Value)) + 
  geom_histogram(bins=50, color="black", fill="white") +
  xlab("P value") +
  ggtitle(glue("P value distribution at nSV={nsv}\nFDR q < 0.05 #{nsig} permutation p={p}")) +
  theme_bw(base_size=10)
```

```{r, include=TRUE}
ggarrange(p1, p2, labels=c("A", "B"), widths = c(1, 2))
```


#### Volcano plot

```{r, include=TRUE}
pd <- fit[!is.na(P.Value),]
pd[, Color := "none"]
pd[adj.P.Val < 0.05 & sign(logFC) < 0, Color := "hypo"]
pd[adj.P.Val < 0.05 & sign(logFC) > 0, Color := "hyper"]
pd[, Color := factor(Color, levels = c("none", "hypo", "hyper"))]

p1 <-pd %>%
  .[ sample(.N, floor(.N * 0.2)), ] %>% 
  ggplot(., aes(logFC, -log10(P.Value), 
                color = Color)) + 
  geom_point(size=1.5) + 
  xlab("Fold change") + 
  ylab("-log10(P)") + 
  scale_color_manual("Direction", 
    values = c("grey50", "#1f78b4", "#33a02c")) +
  guides(color = FALSE) + 
  theme_bw(base_size=10)


p2 <- pd %>%
  .[ sample(.N, floor(.N * 0.2)), ] %>% 
  ggplot(., aes(abs(AveExpr), abs(logFC), 
                color = Color)) + 
  geom_point(alpha=0.4, size=1.5) + 
  xlab("Absolute average modification") + 
  ylab("Absolute fold change") + 
  scale_color_manual("Direction", 
    values = c("grey50", "#1f78b4", "#33a02c")) +
  theme_bw(base_size=10)

ggarrange(p1, p2, ncol=2, labels = LETTERS[1:2],
  common.legend = TRUE)

rm(pd, p1, p2)
```

#### Manhattan plot & Download

```{r}

# touch()
g(p1, p2) %=% cache(
  foo=manhattanPlot, 
  fname=glue("{prefix}manhattan.RDS"), 
  verbose=FALSE, 
  fit=fit)

pdf(glue("www/{prefix}manhattan.pdf"), width=7.2, height=7.2/2)
ggarrange(p1, p2, labels=c("A", "B"), widths = c(3, 1))
dev.off()

```


```{r, include=TRUE, fig.width=7.2, fig.height=7.2/2}
p1 <- p1 +  
  theme_bw(base_size=12) +
  theme( 
    legend.position="none",
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank()
  )

p2 <- p2 + 
  theme_bw(base_size=12) + 
  theme( 
    panel.border = element_blank(),
    panel.grid.major.x = element_blank(),
    panel.grid.minor.x = element_blank(),
    axis.text.x = element_text(angle = 45, hjust = 1)
  )

ggarrange(p1, p2, labels=c("A", "B"), widths = c(3, 1))
```

```{r, include=TRUE, results="asis"}
  cat(glue("[PDF](www/{prefix}manhattan.pdf)\n\n"))
```

```{r}
# prepare result file
fname <- paste0(glue("www/{prefix}"), basename(getwd()), ".csv")
dir.create("www", showWarnings = FALSE)
fwrite(fit, file = fname, row.names = FALSE)
```

```{r, include=TRUE, results='asis'}
cat(paste0("[Download results](", fname, ")\n"))
```

